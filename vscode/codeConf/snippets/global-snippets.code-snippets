{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"Jest Describe Block": {
		"prefix": "describe",
		"scope": "javascript,typescript",
		"body": "describe('$1', () => {$2})",
	},
	"Jest It Block": {
		"prefix": "it",
		"scope": "javascript,typescript",
		"body": "it('$1', () => {$2})",
	},
	"Import": {
		"prefix": "import",
		"scope": "javascript,typescript,javascriptreact,typescriptreact",
		"body": "import {$2} from '$1';",
	},
	"Import React Native": {
		"prefix": "imrn",
		"scope": "javascriptreact,typescriptreact",
		"body": "import { StyleSheet, Text, View } from 'react-native';",
	},
	"Create React Native StyleSheet": {
		"prefix": "rnstyle",
		"scope": "javascriptreact,typescriptreact",
		"body": "const styles = StyleSheet.create({$1})",
	},
	"useState": {
		"prefix": "useState",
		"scope": "javascriptreact,typescriptreact",
		"body": "const [$1, set_$1] = React.useState($2);",
	},
	"useEffect": {
		"prefix": "useEffect",
		"scope": "javascriptreact,typescriptreact",
		"body": "React.useEffect(() => {$1}, [$2]);",
	},
	"useMemo": {
		"prefix": "useMemo",
		"scope": "javascriptreact,typescriptreact",
		"body": "React.useMemo(() => {$1}, [$2]);",
	},
	"useCallback": {
		"prefix": "useCallback",
		"scope": "javascriptreact,typescriptreact",
		"body": "React.useCallback(() => {$1}, [$2]);",
	},
	"GraphQL Root Resolver": {
		"prefix": "graphql root resolver",
		"body": [
			// tslint:disable:interface-over-type-literal
			"import {",
				"GraphQLNonNull,",
				"GraphQLFieldConfig,",
				"GraphQLInputObjectType,",
				"GraphQLInputFieldConfig,",
				"GraphQLObjectType,",
				"GraphQLString,",
				"GraphQLID,",
				"GraphQLList,",
			"} from 'graphql';",
			"import * as lodash from 'lodash';",
			"import { RequestStatusEnum, RequestStatusEnumT } from '../../graphql/types';",
			"",
			"",
			"// ts types",
			"import { MinglContext } from '../../../types';",
			"",
			"// ============================================================================",
			"// Input type",
			"interface XXXXXXXXXXXInputT {}",
			"",
			"export const XXXXXXXXXXXInputSchema = new GraphQLInputObjectType({",
				"name: 'XXXXXXXXXXXInput',",
				"fields: {},",
			"});",
			"",
			"type InputFieldsT = RequireShapeOf<",
				"XXXXXXXXXXXInputT,",
				"GraphQLInputFieldConfig",
			">;",
			"",
			"const inputFields: InputFieldsT = {};",
			"",
			"const XXXXXXXXXXXInputType = new GraphQLInputObjectType({",
				"name: 'XXXXXXXXXXXInput',",
				"fields: inputFields,",
			"});",
			"",
			"// ============================================================================",
			"// Output type",
			"interface XXXXXXXXXXXResolverOutputT {",
				"status: RequestStatusEnumT;",
				"message: string;",
			"}",
			"",
			"const XXXXXXXXXXXOutputType = new GraphQLObjectType({",
				"name: 'XXXXXXXXXXXOutput',",
				"fields: {",
					"status: { type: new GraphQLNonNull(RequestStatusEnum) },",
					"message: { type: new GraphQLNonNull(GraphQLString) },",
				"},",
			"});",
			"",
			"type QuerySrc = {};",
			"type QueryArgs = { input: XXXXXXXXXXXInputT };",
			"",
			"// ============================================================================",
			"// Field schema",
			"",
			"type FieldSchemaT = GraphQLFieldConfig<QuerySrc, MinglContext, QueryArgs>;",
			"",
			"export const XXXXXXXXXXXField: FieldSchemaT = {",
				"type: XXXXXXXXXXXOutputType,",
				"args: {",
					"input: { type: new GraphQLNonNull(XXXXXXXXXXXInputType) },",
				"},",
				"resolve: async (",
					"src,",
					"args: QueryArgs,",
					"ctx: MinglContext",
				"): Promise<XXXXXXXXXXXResolverOutputT> => {",
					"const { user: viewer, requestLogger: logger } = ctx;",
					"logger.info(`Mutation: XXXXXXXXXXX`);",
					"",
					"if (!viewer) {",
						"throw new Error('Unauthenticated');",
					"}",
					"",
					"return {",
						"status: RequestStatusEnumT.OK,",
						"message: 'OK',",
					"};",
				"},",
			"};",

		],
		"description": "Init GQL root resolver"
	}


}